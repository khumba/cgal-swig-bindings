#!/usr/bin/env bash

# Enable "Bash strict mode."
set -euo pipefail

success=0

# Displays a message.
msg() { echo "scilab-gen.sh: $*"; }

# Displays an error message and exits immediately.
err() { msg "Error: $@" >&2; exit 1; }

# Displays an error message and causes the script to return non-zero when it
# exits.
fail() { msg "Error: $@" >&2; success=2; }

usage() {
    cat <<EOF
Scilab interface generator

Usage: ./scilab-gen.sh

Generates a wrapper around the standard Scilab interface that SWIG creates.
This wrapper provides hierarchical names that avoid the 24-character Scilab
variable name limit.

The following arguments are required:

    --module-name <module>             (e.g. Kernel)
    --input <rename_source_file.ren>
    --out-swig <renames.i>
    --out-scilab <sciloader.sce>

This program will read the input file, which contains a description of the
interface that should be exposed to Scilab, and generate output files to make
this happen.  See doc/scilab.md for more details.
EOF
}

if [[ $# -eq 0 ]]; then
    usage
    exit 0
fi

while [[ $# -ne 0 ]]; do
    case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        --module-name)
            shift
            moduleName="${1:?--module-name expects an argument.}"
            ;;
        --input)
            shift
            inputPath="${1:?--input expects an argument.}"
            ;;
        --out-swig)
            shift
            outSwigPath="${1:?--out-swig expects an argument.}"
            ;;
        --out-scilab)
            shift
            outScilabPath="${1:?--out-scilab expects an argument.}"
            ;;
    esac
    shift
done

# KEEP THESE LISTS IN SYNC WITH /SWIG_CGAL/common.i!
#
# In this first list, the alphabetic name should match that in common.i.
operatorSciName() {
    case "${1?operatorSciName requires an operator name argument.}" in
        '+') echo plus;;
        '-') echo minus;;
        '*') echo times;;
        '/') echo div;;
        '+=') echo iplus;;
        '-=') echo iminus;;
        '*=') echo itimes;;
        '/=') echo idiv;;
        '==') echo equals;;
        '!=') echo not_equals;;
        '<') echo lt;;
        '<=') echo le;;
        '>') echo gt;;
        '>=') echo ge;;
    esac
}

# This list, on the other hand, should have short identifiers that won't clash
# with autogenerated wrapper names.
operatorWrapperName() {
    case "${1?operatorSciName requires an operator name argument.}" in
        '+') echo MA;;
        '-') echo MS;;
        '*') echo MM;;
        '/') echo MD;;
        '+=') echo NA;;
        '-=') echo NS;;
        '*=') echo NM;;
        '/=') echo ND;;
        '==') echo EE;;
        '!=') echo EN;;
        '<') echo CA;;
        '<=') echo CB;;
        '>') echo CC;;
        '>=') echo CD;;
    esac
}

declare -r moduleName="${moduleName:?--module-name is a required argument.}"
declare -r inputPath="${inputPath:?--input is a required argument.}"
declare -r outSwigPath="${outSwigPath:?--out-swig is a required argument.}"
declare -r outScilabPath="${outScilabPath:?--out-scilab is a required argument.}"
# This is the path to the SWIG-generated Scilab loader, relative to
# $outScilabPath:
declare -r innerLoaderPath=loader.sce

if [[ $(basename "$outScilabPath") = "$innerLoaderPath" ]]; then
    err \
        "--out-scilab path (${outScilabPath}) should be distinct from the" \
        "inner loader path (${innerLoaderPath})."
fi

# Open the files for reading and writing.
exec \
    {inputFd}< <(cpp "$inputPath") \
    {outSwigFd}>"$outSwigPath" \
    {outScilabFd}>"$outScilabPath"

saySwig() { echo "$@" >&$outSwigFd; }
sayScilab() { echo "$@" >&$outScilabFd; }

declare -r sciCgalRoot="cgal"
sayScilab "mode(-1);"
sayScilab "exec(fullfile(get_absolute_file_path('$(basename "$outScilabPath")'), '${innerLoaderPath}'));"
# This function initializes the SWIG module (runtime type info, etc.).
sayScilab "CGAL_${moduleName}_Scilab_Init();"
sayScilab
sayScilab "${sciCgalRoot} = struct();"

# Go through the input file line by line.
functionIdx=0
class=  # The current class name (empty until a class is declared).
classIdx=0
classLabel=  # An intermediate name for the class.
classSciPath=  # The path under the 'cgal' namespace to the class in Scilab.
memberIdx=0
hasFunctionsWithoutNamespaces=
hasLongSciClassNames=
hasLongSciMethodNames=
hasLongWrapperNames=

# Usage: defFunction cppFunctionPath [sciFunctionName | -]
defFunction() {
    # The C++ path to the function, including namespaces.
    local -r functionPath="${1:?}"
    # The C++ function name, without namespaces.
    local -r functionName="${functionPath##*::}"
    # The Scilab name of the function.
    local functionSci="${2:-}"

    if ! [[ $functionPath = *::* ]]; then
        fail "The function specification \"${functionPath}\" should include" \
             "namespaces."
        if [[ -z $hasFunctionsWithoutNamespaces ]]; then
            hasFunctionsWithoutNamespaces=1
            fail "...See the documentation for 'function' in doc/scilab.md."
        fi
        return 1
    fi

    # Is the function an operator function?
    local isOperator=
    if [[ $functionName = operator* ]] && ! [[ $functionName = operator[a-zA-Z0-9_]* ]]; then
       isOperator=1
    fi
    local -r isOperator

    # Defaulting for the Scilab name.  If it's absent, empty, or "-", then
    # Scilab will use the C++ name.
    if [[ -z $functionSci ]] || [[ $functionSci = - ]]; then
        if [[ -n $isOperator ]]; then
            functionSci="$(operatorSciName "${functionName#operator}")"
        else
            functionSci="$functionName"
        fi
    fi
    local -r functionSci

    if [[ ${#functionSci} -gt 24 ]]; then
        fail \
            "The Scilab name \"${functionSci}\" for \"${functionPath}\"" \
            "mustn't be longer than 24 characters, is ${#functionSci}" \
            "characters.  Please provide a second argument to the 'function'" \
            "command to change the Scilab name."
        return 1
    fi

    # Determine the name of the SWIG wrapper function.
    local functionRename
    if [[ -n $isOperator ]]; then
        functionRename="swigCgalF$(operatorWrapperName "${functionName#operator}")"
    else
        : $((functionIdx++))
        functionRename="swigCgalF${functionIdx}"
    fi
    local -r functionRename

    # Emit a %rename directive and bind a nested Scilab name to the intermediate
    # wrapper name.
    saySwig "%rename (\"${functionRename}\") ${functionPath};"
    sayScilab "${sciCgalRoot}.${functionSci} = ${functionRename};"
    return 0
}

# Usage: defClass CppClassName [SciClassName]
defClass() {
    class="${1:?}"
    classSci="${2:-${class}}"
    classSciPath="${sciCgalRoot}.${classSci/::/.}"
    memberIdx=0

    # Make sure we're not going to overrun Scilab's 24-character variable name
    # limit.
    if [[ ${#classSci} -gt 24 ]]; then
        fail \
            "The Scilab name \"${classSci}\" for class \"${class}\"" \
            "mustn't be longer than 24 characters, is ${#classSci} characters."
        if [[ -z $hasLongSciClassNames ]]; then
            hasLongSciClassNames=1
            fail \
                "...Please provide a second argument to the 'class' command" \
                "to change the Scilab name."
        fi
        return 1
    fi

    saySwig "%rename (\"${classSci}\", %\$isclass) ${class};"
    sayScilab "${classSciPath} = struct();"

    if ! bindMember "new" "new_${classSci}" || \
            ! bindMember "delete" "delete_${classSci}"; then
        fail \
            "...Please provide a second argument to the 'class' command to" \
            "shorten the Scilab name."
        return 1
    fi
    return 0
}

# Usage: defMember cppMemberName [sciMemberName | -] [wrapperName]
defMember() {
    # The C++ name of the member.
    local -r member="${1:?}"
    # The Scilab name of the member.
    local memberSci="${2:-}"
    # The name of the SWIG intermediate wrapper.
    local memberRename="${3:-}"

    if [[ -z $class ]]; then
        fail "Cannot define member \"${member}\" outside of a class."
        return 1
    fi

    # Is the member an operator function?
    local isOperator=
    if [[ $member = operator* ]] && ! [[ $member = operator[a-zA-Z0-9_]* ]]; then
       isOperator=1
    fi
    local -r isOperator

    # Defaulting for the Scilab name.  If it's absent, empty, or "-", then
    # Scilab will use the C++ name.
    if [[ -z $memberSci ]] || [[ $memberSci = - ]]; then
        if [[ -n $isOperator ]]; then
            memberSci="$(operatorSciName "${member#operator}")"
        else
            memberSci="$member"
        fi
    fi
    local -r memberSci

    # Determine the name of the SWIG wrapper function.
    local memberRename
    if [[ -n $isOperator ]]; then
        memberRename="$(operatorWrapperName "${member#operator}")"
    else
        : $((memberIdx++))
        memberRename="M${memberIdx}"
    fi
    local -r memberRename
    local -r memberWrapper="${class}_${memberRename}"

    if [[ ${#memberWrapper} -gt 24 ]]; then
        fail \
            "The Scilab wrapper name \"${memberWrapper}\" for" \
            "\"${class}::${member}\" mustn't be longer than 24 characters, is" \
            "${#memberWrapper} characters."
        if [[ -z $hasLongWrapperNames ]]; then
            hasLongWrapperNames=1
            fail \
                "...Please provide a third argument to the 'method' command" \
                "to override the suffix after \"${class}_\", or else shorten" \
                "the class name."
        fi
    fi

    # Emit a %rename directive and bind a nested Scilab name to the intermediate
    # wrapper name.
    saySwig "%rename (\"${memberRename}\") ${class}::${member};"
    if ! bindMember "$memberSci" "$memberWrapper"; then
        if [[ -z $hasLongSciMethodNames ]]; then
            hasLongSciMethodNames=1
            fail \
                "...Please provide a second argument to the 'member' command" \
                "to change the Scilab name."
            return 1
        fi
    fi
    return 0
}

# Usage: bindMember sciMemberName sciExpr (bind-member | member)
bindMember() {
    local -r memberSci="${1:?}"
    local -r expr="${2:?}"

    if [[ -z $class ]]; then
        fail "Cannot bind member \"${memberSci}\" outside of a class."
        return 1
    fi

    # Make sure we're not going to overrun Scilab's 24-character variable name
    # limit.
    if [[ ${#memberSci} -gt 24 ]]; then
        fail \
            "The Scilab name \"${memberSci}\" for \"${class}::${member}\"" \
            "mustn't be longer than 24 characters, is ${#memberSci} characters."
    fi

    sayScilab "${classSciPath}.${memberSci} = ${expr};"
    return 0
}

# Need to disable error checking for read, because it returns non-zero on EOF.
set +e
while read -r line <&$inputFd; do
    set -e
    line="${line%%#*}"  # cpp emits "# ..." directives; ignore them.
    line="${line%%//*}"  # Allow for line comments with "//".

    read -ra words <<<"$line"  # Split the line into words.
    if [[ ${#words[@]} -eq 0 ]]; then continue; fi
    case "${words[0]}" in
        function)
            if ! defFunction \
                "${words[1]:?'function' requires a C++ function to bind to.}" \
                "${words[2]:-}"; then
                fail "...processing line: \"${words[@]}\""
            fi
            ;;
        bind-member)
            # TODO Switch to (argc >= x && argc <= y), to check for extra arguments.
            if ! bindMember \
                "${words[1]:?'bind-member' command requires a Scilab member to bind to.}" \
                "${words[2]:?'bind-member' command requires a Scilab variable to bind from.}"; then
                fail "...processing line: \"${words[@]}\""
            fi
            ;;
        class)
            if ! defClass \
                "${words[1]:?'class' command requires a class identifier.}" \
                "${words[2]:-}"; then
                fail "...processing line: \"${words[@]}\""
            fi
            ;;
        member)
            if ! defMember \
                "${words[1]:?'member' command requires a member identifer.}" \
                "${words[2]:-}" \
                "${words[3]:-}"; then
                fail "...processing line: \"${words[@]}\""
            fi
            ;;
        trait)
            case "${words[1]:?'trait' command requires a trait name.}" in
                ordered)
                    if ! defMember "operator<" || \
                            ! defMember "operator<=" || \
                            ! defMember "operator>" || \
                            ! defMember "operator>="; then
                        fail "...processing line: \"${words[@]}\""
                    fi
                    ;&
                equatable)
                    if ! defMember "operator==" || \
                            ! defMember "operator!="; then
                        fail "...processing line: \"${words[@]}\""
                    fi
                    ;;
                *) err "Unknown class trait \"${words[1]}\".";;
            esac
            ;;
        *)
            err "Unrecognized command in input file: \"${words[0]}\""
            exit 1
            ;;
    esac

    set +e
done
set -e

exec {inputFd}<&- {outSwigFd}<&- {outScilabFd}<&-

exit "$success"
